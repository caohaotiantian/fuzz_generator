"""XML Generator for Secray DataModel format.

Generates well-formed XML files from DataModel objects.
"""

import xml.etree.ElementTree as ET
from typing import Any
from xml.dom import minidom

from fuzz_generator.config import OutputSettings, Settings
from fuzz_generator.models.xml_models import (
    BlobElement,
    BlockElement,
    ChoiceElement,
    DataModel,
    DataModelElement,
    NumberElement,
    StringElement,
)
from fuzz_generator.utils import get_logger

logger = get_logger(__name__)


class XMLGenerator:
    """Generator for Secray XML DataModel format."""

    def __init__(
        self,
        settings: Settings | OutputSettings | None = None,
        encoding: str = "utf-8",
        indent: int = 4,
        include_comments: bool = True,
    ):
        """Initialize XML generator.

        Args:
            settings: Application or output settings.
            encoding: XML encoding.
            indent: Indentation spaces (0 for no formatting).
            include_comments: Whether to include descriptive comments.
        """
        if isinstance(settings, Settings):
            output = settings.output
            self.encoding = output.encoding
            self.indent = output.indent
            self.include_comments = output.include_comments
        elif isinstance(settings, OutputSettings):
            self.encoding = settings.encoding
            self.indent = settings.indent
            self.include_comments = settings.include_comments
        else:
            self.encoding = encoding
            self.indent = indent
            self.include_comments = include_comments

    def generate(
        self,
        models: list[DataModel],
        *,
        indent: int | None = None,
        include_comments: bool | None = None,
        include_xml_declaration: bool = True,
    ) -> str:
        """Generate XML from DataModel objects.

        Args:
            models: List of DataModel objects to generate XML for.
            indent: Override default indentation (None uses default).
            include_comments: Override default comment inclusion.
            include_xml_declaration: Whether to include XML declaration.

        Returns:
            Generated XML string.
        """
        _indent = indent if indent is not None else self.indent
        _include_comments = (
            include_comments if include_comments is not None else self.include_comments
        )

        logger.debug(f"Generating XML for {len(models)} DataModel(s)")

        # Create root element
        root = ET.Element("Secray")

        # Add comment if requested
        if _include_comments and models:
            root.append(ET.Comment(" Generated by Fuzz Generator "))

        # Add DataModels
        for model in models:
            datamodel_elem = self._create_datamodel_element(model, _include_comments)
            root.append(datamodel_elem)

        # Generate XML string
        xml_str = self._to_string(root, _indent, include_xml_declaration)

        logger.debug(f"Generated XML: {len(xml_str)} bytes")
        return xml_str

    def generate_single(
        self,
        model: DataModel,
        *,
        indent: int | None = None,
        include_comments: bool | None = None,
    ) -> str:
        """Generate XML for a single DataModel.

        Args:
            model: DataModel object.
            indent: Override default indentation.
            include_comments: Override default comment inclusion.

        Returns:
            Generated XML string.
        """
        return self.generate(
            [model],
            indent=indent,
            include_comments=include_comments,
        )

    def generate_element(self, element: DataModelElement) -> ET.Element:
        """Generate XML Element from a DataModelElement.

        Args:
            element: DataModelElement to convert.

        Returns:
            XML Element.
        """
        if isinstance(element, StringElement):
            return self._create_string_element(element)
        elif isinstance(element, NumberElement):
            return self._create_number_element(element)
        elif isinstance(element, BlobElement):
            return self._create_blob_element(element)
        elif isinstance(element, BlockElement):
            return self._create_block_element(element)
        elif isinstance(element, ChoiceElement):
            return self._create_choice_element(element)
        else:
            raise ValueError(f"Unknown element type: {type(element)}")

    def _create_datamodel_element(
        self,
        model: DataModel,
        include_comments: bool,
    ) -> ET.Element:
        """Create DataModel XML element."""
        elem = ET.Element("DataModel")
        elem.set("name", model.name)

        # Add description as comment if present
        if include_comments and model.description:
            elem.append(ET.Comment(f" {model.description} "))

        # Add child elements
        for child in model.elements:
            child_elem = self.generate_element(child)
            elem.append(child_elem)

        return elem

    def _create_string_element(self, element: StringElement) -> ET.Element:
        """Create String XML element."""
        elem = ET.Element("String")
        for attr, value in element.to_xml_attrs().items():
            elem.set(attr, value)
        return elem

    def _create_number_element(self, element: NumberElement) -> ET.Element:
        """Create Number XML element."""
        elem = ET.Element("Number")
        for attr, value in element.to_xml_attrs().items():
            elem.set(attr, value)
        return elem

    def _create_blob_element(self, element: BlobElement) -> ET.Element:
        """Create Blob XML element."""
        elem = ET.Element("Blob")
        for attr, value in element.to_xml_attrs().items():
            elem.set(attr, value)
        return elem

    def _create_block_element(self, element: BlockElement) -> ET.Element:
        """Create Block XML element."""
        elem = ET.Element("Block")
        for attr, value in element.to_xml_attrs().items():
            elem.set(attr, value)

        # Add child elements if any
        for child in element.children:
            child_elem = self.generate_element(child)
            elem.append(child_elem)

        return elem

    def _create_choice_element(self, element: ChoiceElement) -> ET.Element:
        """Create Choice XML element."""
        elem = ET.Element("Choice")
        for attr, value in element.to_xml_attrs().items():
            elem.set(attr, value)

        # Add options
        for option in element.options:
            option_elem = self.generate_element(option)
            elem.append(option_elem)

        return elem

    def _to_string(
        self,
        root: ET.Element,
        indent: int,
        include_declaration: bool,
    ) -> str:
        """Convert ElementTree to formatted string."""
        # Convert to string
        rough_string = ET.tostring(root, encoding="unicode")

        if indent > 0:
            # Use minidom for pretty printing
            dom = minidom.parseString(rough_string)

            if include_declaration:
                xml_str = dom.toprettyxml(
                    indent=" " * indent,
                    encoding=None,
                )
                # Fix encoding declaration
                xml_str = xml_str.replace(
                    '<?xml version="1.0" ?>',
                    f'<?xml version="1.0" encoding="{self.encoding}"?>',
                )
            else:
                # Get root element without declaration
                xml_str = dom.documentElement.toprettyxml(
                    indent=" " * indent,
                )

            # Remove extra blank lines
            lines = [line for line in xml_str.split("\n") if line.strip()]
            return "\n".join(lines)
        else:
            # No formatting
            if include_declaration:
                return f'<?xml version="1.0" encoding="{self.encoding}"?>{rough_string}'
            return rough_string

    def generate_to_file(
        self,
        models: list[DataModel],
        file_path: str,
        *,
        indent: int | None = None,
        include_comments: bool | None = None,
    ) -> None:
        """Generate XML and write to file.

        Args:
            models: List of DataModel objects.
            file_path: Output file path.
            indent: Override default indentation.
            include_comments: Override default comment inclusion.
        """
        xml_str = self.generate(models, indent=indent, include_comments=include_comments)

        with open(file_path, "w", encoding=self.encoding) as f:
            f.write(xml_str)

        logger.info(f"Generated XML written to: {file_path}")

    def generate_from_dict(
        self,
        data: dict[str, Any] | list[dict[str, Any]],
        *,
        indent: int | None = None,
    ) -> str:
        """Generate XML from dictionary representation.

        Args:
            data: Dictionary or list of dictionaries representing DataModels.
            indent: Override default indentation.

        Returns:
            Generated XML string.
        """
        if isinstance(data, dict):
            data = [data]

        models = [DataModel.from_dict(d) for d in data]
        return self.generate(models, indent=indent)
